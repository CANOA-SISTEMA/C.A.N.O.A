<!doctype html>
<html lang="pt-BR">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>3 chances - Barra corrigida</title>
<style>
  html,body{height:100%;margin:0;background:#000;color:#fff;font-family:monospace;overflow:hidden;transition:background .35s ease;}
  .wrap{height:100%;display:flex;flex-direction:column;justify-content:center;align-items:center;gap:25px;transition:opacity .25s, visibility .25s;}
  .wrap.hidden{opacity:0;visibility:hidden;pointer-events:none;}
  .title{font-size:32px;text-shadow:2px 0 red,-2px 0 cyan;}
  .password-line{display:flex;gap:12px;}
  .char{width:35px;height:45px;border-bottom:3px solid #444;display:flex;align-items:center;justify-content:center;font-size:20px;color:transparent;transition:border-color .2s, color .2s;}
  .char.filled{border-bottom-color:#ddd;color:#ddd;}
  body.chaos{background:#2b0033;}
  body.chaos .char.filled{border-bottom-color:#a020f0;color:#a020f0;}
  .glitch{position:fixed;inset:0;background:repeating-linear-gradient(0deg, rgba(255,0,0,.2) 0px, rgba(0,255,255,.2) 2px, transparent 4px);mix-blend-mode:screen;pointer-events:none;opacity:0;z-index:20;transition:opacity .15s;}
  .glitch.show{animation:glitchHeavy .08s infinite;opacity:1;}
  @keyframes glitchHeavy{0%{transform:translate(0,0);opacity:.2}25%{transform:translate(-5px,3px);opacity:.6}50%{transform:translate(5px,-3px);opacity:.8}75%{transform:translate(-3px,2px);opacity:.5}100%{transform:translate(0,0);opacity:.7}}
  .shake{animation:shakeScreen .1s infinite;}
  @keyframes shakeScreen{0%{transform:translate(0,0);}25%{transform:translate(-8px,5px);}50%{transform:translate(8px,-5px);}75%{transform:translate(-5px,3px);}100%{transform:translate(0,0);}}
  .download-box{position:fixed;bottom:80px;left:50%;transform:translateX(-50%);width:75%;max-width:900px;display:flex;flex-direction:column;gap:20px;z-index:40;pointer-events:none;opacity:0;visibility:hidden;transition:opacity .25s, visibility .25s;}
  .download-box.show{opacity:1;visibility:visible;}
  .percent{font-size:70px;font-weight:bold;color:#a020f0;text-shadow:0 0 20px #a020f0;text-align:center;}
  .bar{width:100%;height:45px;border:4px solid #a020f0;padding:6px;box-shadow:0 0 25px #a020f0;}
  .bar-fill{width:0%;height:100%;background:#a020f0;transition:width .12s linear;}
  .symbol{position:fixed;top:50%;left:50%;transform:translate(-50%,-50%) scale(.6);width:180px;max-width:40vw;z-index:9999;opacity:0;visibility:hidden;transition:all .35s ease;pointer-events:none;}
  .symbol.show{opacity:1;visibility:visible;transform:translate(-50%,-50%) scale(1);}
  .symbol-fallback{position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);color:#fff;background:rgba(0,0,0,0.35);padding:18px 22px;border-radius:8px;z-index:9999;font-family:monospace;display:none;}
  .symbol-fallback.show{display:block;}
  .fade-out{opacity:0 !important;visibility:hidden !important;}
</style>
</head>
<body>

  <div class="wrap" id="mainWrap">
    <div class="title" id="titleText">3 chances</div>
    <div class="password-line" id="boxes"></div>
  </div>

  <input id="input" type="password" maxlength="7" autocomplete="off" autocapitalize="off" style="position:fixed;left:-9999px;">

  <div class="glitch" id="glitch"></div>

  <div class="download-box" id="downloadBox">
    <div class="percent" id="percentText">0%</div>
    <div class="bar"><div class="bar-fill" id="barFill"></div></div>
  </div>

  <img id="symbol" class="symbol" src="./simbolo.png" alt="símbolo final" style="display:block;"/>
  <div id="symbolFallback" class="symbol-fallback">[símbolo indisponível]</div>

  <audio id="music" src="glitch.mp3" preload="auto"></audio>

<script>
/* ======= Config ======= */
const PASSWORD = "hegemol";
const LEN = 7;
const MAX_ATTEMPTS = 3;
const BUFFER_MS = 500; // quanto antes a barra completa antes do fim do áudio (ms)

/* ======= DOM ======= */
const input = document.getElementById("input");
const boxes = document.getElementById("boxes");
const glitch = document.getElementById("glitch");
const downloadBox = document.getElementById("downloadBox");
const percentText = document.getElementById("percentText");
const barFill = document.getElementById("barFill");
const music = document.getElementById("music");
const titleText = document.getElementById("titleText");
const symbol = document.getElementById("symbol");
const symbolFallback = document.getElementById("symbolFallback");
const mainWrap = document.getElementById("mainWrap");

let attempts = 0;
let progressRAF = null;
let progressTargetEnd = null; // em segundos
let prepared = false;

/* ======= Inicialização UI ======= */
titleText.textContent = `${MAX_ATTEMPTS} chances`;
for (let i = 0; i < LEN; i++){
  const d = document.createElement("div");
  d.className = "char";
  boxes.appendChild(d);
}
function updateBoxes(v){
  const length = v ? v.length : 0;
  [...boxes.children].forEach((b,i)=>{
    b.classList.toggle("filled", i < length);
    b.textContent = i < length ? "•" : "";
  });
}

/* foco ao clicar na página */
document.addEventListener('click', ()=>{ try{ input.focus(); }catch(e){} });

/* autoplay unlock attempt */
document.addEventListener("click", () => {
  music.play().then(()=>{ music.pause(); music.currentTime = 0; }).catch(()=>{});
}, { once: true });

input.addEventListener("input", e => {
  const val = e.target.value.slice(0, LEN);
  e.target.value = val;
  updateBoxes(val);
});
input.value = "";
setTimeout(()=>{ try{ input.focus(); }catch(e){} }, 50);

function updateTitleRemaining(remaining){
  if (remaining > 1) titleText.textContent = `${remaining} chances`;
  else if (remaining === 1) titleText.textContent = `1 chance`;
  else titleText.textContent = `0 chances`;
}

/* ======= Entradas / Enter ======= */
input.addEventListener("keydown", e=>{
  if (e.key === "Enter") {
    const v = input.value;
    if (v.length !== LEN) return;
    if (v.toLowerCase() === PASSWORD) { alert("ACESSO LIBERADO"); return; }

    attempts++;
    input.value = "";
    updateBoxes("");
    const remaining = MAX_ATTEMPTS - attempts;
    updateTitleRemaining(remaining);

    if (attempts === MAX_ATTEMPTS) {
      updateTitleRemaining(0);
      activateChaos();
    }
  }
});

/* ======= Símbolo fallback ======= */
symbol.addEventListener('error', ()=> console.warn('simbolo.png não foi encontrado. Usando fallback textual.'));
function showSymbolOrFallback(){
  if (symbol.complete && symbol.naturalWidth && symbol.naturalWidth > 0) symbol.classList.add('show');
  else symbolFallback.classList.add('show');
}

/* ======= Ativar caos ======= */
function activateChaos(){
  // desabilita input
  input.disabled = true;
  input.style.display = 'none';

  // aplica efeitos visuais
  document.body.classList.add('chaos','shake');
  glitch.classList.add('show');
  downloadBox.classList.add('show');

  // reset barra
  barFill.style.width = "0%";
  percentText.textContent = "0%";
  symbol.classList.remove('show');
  symbolFallback.classList.remove('show');

  // inicia áudio
  music.currentTime = 0;
  const p = music.play();

  // preparamos comportamento dependendo de play() ser permitido
  if (p && typeof p.then === 'function') {
    p.then(()=> {
      prepareProgressForAudio();
    }).catch(()=> {
      // play bloqueado -> fallback temporal
      prepareProgressFallback();
    });
  } else {
    // alguns navegadores retornam undefined
    prepareProgressForAudio();
  }
}

/* ======= Preparação baseada no audio ======= */
function prepareProgressForAudio(){
  // se já temos duration válido, configura; caso contrário espera loadedmetadata
  if (music.duration && !isNaN(music.duration) && music.duration > 0.1) {
    setProgressTargetFromDuration(music.duration);
    startProgressLoop();
  } else {
    const onMeta = () => {
      if (music.duration && !isNaN(music.duration) && music.duration > 0.1) {
        music.removeEventListener('loadedmetadata', onMeta);
        setProgressTargetFromDuration(music.duration);
        startProgressLoop();
      }
    };
    music.addEventListener('loadedmetadata', onMeta);
    // fallback curto caso loadedmetadata já tenha ocorrido mas listener não foi chamado
    setTimeout(()=> {
      if (music.duration && !isNaN(music.duration) && music.duration > 0.1) {
        music.removeEventListener('loadedmetadata', onMeta);
        setProgressTargetFromDuration(music.duration);
        startProgressLoop();
      }
    }, 200);
  }

  // garante 100% se o áudio terminar cedo
  music.addEventListener('ended', ()=> {
    // se barra já completou, onProgressCompleteBeforeAudioEnd lidou com limpeza
    // se não, forçamos 100% e executamos limpeza
    if (!isProgressComplete()) {
      forceCompleteProgress();
    }
  }, { once: true });
}

/* ======= Fallback quando play() bloqueado ======= */
function prepareProgressFallback(){
  const fallbackMs = 3800;
  setProgressTargetFromDuration(fallbackMs / 1000); // transforma em segundos
  startProgressLoop();
  setTimeout(()=> cleanupAfterProgress(), fallbackMs + 200);
}

/* ======= Cálculo do target ======= */
function setProgressTargetFromDuration(durationSec){
  const bufferSec = BUFFER_MS / 1000;
  if (!isFinite(durationSec) || durationSec <= 0) {
    // fallback defensivo
    progressTargetEnd = 3.8; // 3.8s
  } else if (durationSec <= bufferSec + 0.2) {
    // se muito curto, mapeia pra 90% do áudio
    progressTargetEnd = durationSec * 0.90;
  } else {
    // normalmente queremos que a barra complete ANTES do fim: duration - buffer
    progressTargetEnd = Math.max(0.05, durationSec - bufferSec);
    // garantir que progressTargetEnd não exceda durationSec (defensivo)
    if (progressTargetEnd > durationSec) progressTargetEnd = durationSec;
  }
  prepared = true;
  // console.log('progressTargetEnd (s):', progressTargetEnd, 'duration (s):', durationSec);
}

/* ======= Loop principal (usa currentTime do audio) ======= */
function startProgressLoop(){
  if (!prepared) return;
  if (progressRAF) cancelAnimationFrame(progressRAF);

  const epsilonSec = 0.04; // tolerância: se currentTime >= target - epsilon, consideramos completo

  function step(){
    // se target inválido, agendamos novo frame até ficar válido
    if (typeof progressTargetEnd !== 'number' || !isFinite(progressTargetEnd) || progressTargetEnd <= 0) {
      progressRAF = requestAnimationFrame(step);
      return;
    }

    // current time do audio (segundos)
    const currentSec = (typeof music.currentTime === 'number') ? music.currentTime : 0;

    // calcula percent com mapeamento para completar em progressTargetEnd
    let p = (currentSec / progressTargetEnd) * 100;
    // cap
    if (p < 0) p = 0;
    if (p > 100) p = 100;

    // atualização visual
    barFill.style.width = p.toFixed(2) + "%";
    percentText.textContent = Math.floor(p) + "%";

    // se atingimos (ou ultrapassamos) target com tolerância, marcamos como completo
    if (currentSec + epsilonSec >= progressTargetEnd || p >= 100) {
      onProgressCompleteBeforeAudioEnd();
      return;
    }

    // caso o áudio termine inesperadamente, garantimos completar
    if (music.ended) {
      forceCompleteProgress();
      return;
    }

    // caso contrário, continua atualizando
    progressRAF = requestAnimationFrame(step);
  }

  progressRAF = requestAnimationFrame(step);
}

/* ======= Verificador de estado de conclusão ======= */
function isProgressComplete(){
  return barFill.style.width === "100%" || percentText.textContent === "100%";
}

/* ======= Ao completar antes do audio acabar ======= */
function onProgressCompleteBeforeAudioEnd(){
  // força 100%
  barFill.style.width = "100%";
  percentText.textContent = "100%";

  // mostra símbolo/fallback
  showSymbolOrFallback();

  // limpa RAF
  if (progressRAF) { cancelAnimationFrame(progressRAF); progressRAF = null; }

  // pequenas animações de esconder
  setTimeout(()=>{
    downloadBox.classList.remove('show');
    glitch.classList.remove('show');
    // mantenha o fundo 'chaos' se desejar; removemos shake só após curtos instantes
    setTimeout(()=> document.body.classList.remove('shake'), 250);
  }, 220);

  // esconder mainWrap definitivamente
  mainWrap.classList.add('hidden');
  setTimeout(()=> { mainWrap.style.display = 'none'; }, 300);
}

/* ======= Forçar completar (quando audio ended ou condição de fallback) ======= */
function forceCompleteProgress(){
  barFill.style.width = "100%";
  percentText.textContent = "100%";
  showSymbolOrFallback();

  if (progressRAF) { cancelAnimationFrame(progressRAF); progressRAF = null; }

  setTimeout(()=> {
    downloadBox.classList.remove('show');
    glitch.classList.remove('show');
    document.body.classList.remove('shake');
  }, 260);

  mainWrap.classList.add('hidden');
  setTimeout(()=> { mainWrap.style.display = 'none'; }, 300);
}

/* ======= Limpeza final do fallback ======= */
function cleanupAfterProgress(){
  downloadBox.classList.remove('show');
  glitch.classList.remove('show');
  document.body.classList.remove('shake');
  showSymbolOrFallback();
  mainWrap.classList.add('hidden');
  setTimeout(()=> { mainWrap.style.display = 'none'; }, 300);
}

/* ======= (Opcional) Simulações para teste ======= */
/* descomente para testar automaticamente */
// setTimeout(()=>{ input.value='xxxxxxx'; input.dispatchEvent(new Event('input')); input.dispatchEvent(new KeyboardEvent('keydown',{key:'Enter'})); }, 1000);
// setTimeout(()=>{ input.value='yyyyyyy'; input.dispatchEvent(new Event('input')); input.dispatchEvent(new KeyboardEvent('keydown',{key:'Enter'})); }, 1700);
// setTimeout(()=>{ input.value='zzzzzzz'; input.dispatchEvent(new Event('input')); input.dispatchEvent(new KeyboardEvent('keydown',{key:'Enter'})); }, 2400);

</script>
</body>
</html>
